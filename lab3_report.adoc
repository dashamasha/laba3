=== Лабораторная работа №3
Задания:

1) Настроить внешний источник частоты HSE и подключить его на системную шину ( сделали на лабе)
Прошить программу морганиями светодиодом - проверить, что они моргают

За основу был взят код, который мы делали на лабораторной работе. Настроен внешний источник частоты HSE и подключен  на системную шину.

.Исходный код
image::/photo/1.png[]

Была запущена программа и на плате загорелся светодиод с частотой 8 МГц.

2) Настроить внутренний источник частоты HSI и подключить его на системную шину ( сделали на лабе)
Прошить программу морганиями светодиодом - проверить, что они моргают быстрее в 2 раза

Поменяли с внешнего высокочастотного генератора​ на внутренний высокочастный RC-генаратор.

.Исходный код
image::/photo/2.png[]

Светодиоды начали моргать в 2 раза быстрее,чем в пункте 1 (частота 16 МГЦ).

3) Настроить PIL источник тактовой частоты на 32 Мгц и подключить его на системную шину.
Прошить программу морганиями светодиодом - проверить, что они моргают  еще в 2 раза быстрее чем в пункте 2.

.Исходный код
image::/photo/3.png[]

Здесь мы работаем с системой ФАПЧ, которая состоит из набора умножителей и делителей (PLL).
Мы получаем сигнал от HSI (частота 16 МГц), после этого мы разделили на 8 с помощью PLLМ, затем умножили на 64 с помощью PLLN (получилась частота 128 МГц), с помощью PLLQ разделили на 4.
В результате светодиод моргает в 2 раза быстрее, чем в пункте 2.

Ответы на вопросы:

1) POD типы в языке C++ это аббревиатура от “Plain Old Data”, что можно трактовать как «Простые данные в стиле C»

2) Простые:

· целые (bool, char, int, enim, long, short, long long)

· с плавающей точкой (float, double, long double)

· структурированные (array, union, class/structure)

· адресные (pointer, reference)

3) Можем определить свой тип сами, либо сделать псевдоним типа. Любой класс или структура, определенная нами, будет являться нашим типом. Пользовательский тип делается вручную и может иметь любой псевдоним.

4) short int – целочисленное знаковое значение укороченной длины,

unsigned short int – целочисленное беззнаковое значение укороченной длины,

long int – выбор по умолчанию для целочисленных значений. На платформах на которых int равен по длине unsigned short int может быть длиннее int,

unsigned long int – целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть длиннее int,

long double – число с плавающей точкой двойной точности с двойной точностью

5) Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров типов существует правило:

1 <= sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long)

1 <= sizeof(bool) <= sizeof(long)

sizeof(char) <= sizeof(long)

sizeof(float) <= sizeof(double) <= sizeof(long double)

sizeof(T) == sizeof(signed T) == sizeof(unsigned T)

6) Данный унарный оператор используют для вычисления и возвращает размер определённой переменной или определённого типа данных в байтах

7) std::size_t – целочисленный беззнаковый тип результата, возвращаемого операторами sizeof. Может хранить максимальный размер теоретически возможного объекта любого типа (включая массивы). С++ определяет size_t в пространстве имен std.

8)

.Фиксированные типы данных
image::/photo/4.png[]

9) Псевдоним типа является именем, ссылающимся на ранее определённый тип, используется для повышения удобства обращения к пользовательским и встроенным типам данных.

10) Неявное преобразование типов данных выполняет компилятор С++, (int a = 3.14;) а явное преобразование данных выполняет сам программист (int a = static_cast<int>(3.14);).

11) static_cast, const_cast, reinterpret_cast, dynamic_cast

12) reinterpret_cast преобразует типы, несовместимыми друг с другом, и используется для преобразования:

· В свой собственный тип

· Указателя в интегральный тип

· Интегрального типа в указатель

· Указателя одного типа в указатель другого типа

· Указателя на функцию одного типа в указатель на функцию другого типа

13) reinterpret_cast — приведение типов без проверки, непосредственное указание компилятору. Применяется только в случае полной уверенности программиста в собственных действиях. Используется для несовместимых типов.

static_cast преобразует выражения одного статического типа в объекты и значения другого статического типа. Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки. Используется для близких типов

14) ОЗУ – опертивное запоминающее устройство (RAM). Служит для хранения программ начальной загрузки компьютера и тестирования его узлов. Используется только для чтения. Записанная в ней информация не изменяется после выключения компьютера.

ПЗУ – постоянное запоминающее устройство (ROM). Предназначена для хранения информации, изменяющейся в ходе выполнения процессором операций по ее обработке. Используется как для чтения, так и для записи информации. Вся информация хранится в этой памяти только тогда, когда компьютер включен.

15) Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.

16) По Гарвардской модифицированной архитектуре.

17) Гарвардская архитектура. Данные и код программы хранятся в различных блоках памяти и доступ к ним осуществляется через разные шины, как показано на схеме. Т.к. шины работают независимо, выбор команд программы и данных может осуществляться одновременно, повышая таким образом скорость по сравнению со случаем и спользования одной шины вархитектуре Фон Неймана.

Архитектура Фон Неймана. Эта архитектура состоит из единого блока памяти, в котором хранятся и команды, и данные, и общей шины для передачи данных и команд в ЦПУ и от него. При такой архитектуре перемножение двухчисел требует по меньшей мере трех циклов: двух циклов для передачи двух чисел в ЦПУ, и одного – для передачи команды. Данная архитектура приемлема в том случае, когда все действия могут выполняться последовательно.

18) Локальные переменные функции создаются на стеке или в регистрах

19) инициализируемые - .data инициализируемые нулем - .bss данные переменные не изменяются до конца работы приложения.

20) инициализируемые - .data

инициализируемые нулем - .bss

21) Стек – это организация памяти, выполненная компоновщиком. На уровне микроконтроллера для работы со стеком есть специальные ассемблерные команды (например PUSH – положить регистры в стек, и POP – взять из стека).

Так же для сохранения и считывания данных из стека могут использоваться инструкции STR и LDR.

22) 22. Что такое указатель?

Указатель это переменная, которая хранит адрес какой-то другой переменной.

23) Операция, нужная для того, чтобы получить значение, записанное в некоторой области, на которое ссылается указатель

24) Оператор & - оператор взятия адреса.

& перед переменной передает адрес по которому лежат значения этой переменной.

25) Указатели можно складывать+, вычитать -, увеличивать ++, сравнивать !=. Но указатели должны быть одного типа

26) Константный указатель — это указатель, значение которого не может быть изменено после инициализации. Для объявления константного указателя используется ключевое слово const между звёздочкой и именем указателя:

int * const ptr = &value1;

27) Указатель на константное значение — это неконстантный указатель, который указывает на неизменное значение. Для объявления указателя на константное значение, используется ключевое слово const перед типом данных:

const int *ptr = &value;

28)Ссылка – это тип переменной в C, который работает как псевдоним другого объекта или значения. Ссылка – это тот же указатель, который неявно разыменовывается при доступе к значению, на которое он указывает

Поскольку ссылки должны быть инициализированы корректными объектами (они не могут быть нулевыми) и не могут быть изменены позже, то они, как правило, безопаснее указателей (так как риск разыменования нулевого указателя отпадает). Однако, они немного ограничены в функциональности, по сравнению с указателями.

Если определённое задание может быть решено с помощью как ссылок, так и указателей, то лучше использовать ссылки. Указатели следует использовать в ситуациях, только когда ссылки недостаточно эффективны (например, при динамическом выделении памяти).

29) Регистр - это определенный участок памяти внутри самого процессора, от 8-ми до 32-х бит длиной, который используется для промежуточного хранения информации, обрабатываемой процессором. Некоторые регистры содержат только определенную информацию.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

30) Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

31) Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления процессором и периферийными устройствами.

32)Так как регистр специального назначения – это просто адресуемая ячейка памяти, то в коде это может мы можем обратиться к данным по этому адресу, разыменовывая указатель, указывающий на этот адрес.

Для того, чтобы настроить определенное периферийное устройство процессора, необходимо изменить значение поля соответствующем регистре.

Для более удобной работы с регистрами можно использовать С++ обертку. Эта обертка позволяет обращаться к регистрам в форме очень похоже с тем, как эти регистры описаны в документации.

Так, например, для запуска счетчика, необходимо обратиться к регистру “TIM1” периферии “CR1”, полю CEN и установить в нем значение Enable. Операция обращения к регистру выглядит следующим образом:

int main()

{

TIM1::CR1::CEN::Enable::Set() ;

}

Так же мы можем обратиться к данным по этому адресу, разыменовывая указатель, указывающий на этот адрес:

int main()

{

*reinterpret_cast<uint32_t *>(0x40010000) |= 1 << 0 ;


33)Функция должна быть объявлена в таком порядке, чтобы компилятор мог узнать как её вызвать. Объявление функции может выглядеть следующим образом:

int MyFunction(int first, char * second);

Все что знает об этой функции компилятор, это то, что она принимает два параметра: целое и указатель на символ. И функция должна вернуть целое значение. Этого достаточно для компилятора, чтобы понять как вызвать эту функцию.

До выполнения функции происходит инициализация стека, инициализация переменных в нулевые значения, инициализация переменнх, запуск функции.

Вход в функцию

Параметры передающие в функцию могут использовать два метода:

Через регистры

Через стек

Для большей эффективности параметры передаются через регистры, но их число ограничено, поэтому если регистров не хватает, то используется стек. Для передачи параметров используются оперативные регистры R0:R3

Выход из функции:

Функция может вернуть значение. Для возврата значения используются регистры R0:R1. Если значение больше 64 бит, то в регистр R0 записывается адрес где лежат данные.

Вызывающая функция обязана очистить стек, после того, как вызываемая функция вернула значение.

34) Компилятор – программа выполняющая трансляцию исходного кода из предметно-ориентированногоязыка на машинно-ориентированный язык.

Структурно процесс трансляции с помощью компилятора показан на рисунке [Схема Трансляции]. После трансляции вы можете получить на выходе либо файлы библиотеки, которые впоследствии можно будет использовать в других проектах, либо объектные файлы

35) Компоновка – объединение объектных файлов в исполняемый.

36) При создании структуры проекта стоит соблюдать иерархическую структуру файлов, хранящихся на компьюетере. Это позволяет облегчить поиск требуемых компонентов. Структура должна иметь иерархическую модель. Все существующие подгруппы разбивают файлы на логические группы.

37) Оператор — это символ, который сообщает компилятору о необходимости выполнения некоторых математических или логических действий.

38) Операция, присваивание, сложение,вычитание, унарный плюс, унарный минус, деление, умножение, остаток от деления и т.д.

39) Логическое отрицание, логическое сложение, логическое умножение.

40) Побитовая инверсия, побитовое И, побитовое ИЛИ,побитовое исключающее ИЛИ, побитовый сдвиг влево,вправо.

41) class BigInt
{
...
BigInt * operator ->();
char operator [](size_t i) const;
char & operator [](size_t i);
...
};

42) Составное присваивание, операторы работы с указателями и членами класса, функторы, тернарные операции, sizeof(), запятая, приведение типа, new.

43) битовый И и отрицание:
PORTB &= ~1; // сбрасывает 0-ой бит в PORT

44) битовый ИЛИ:
PORT | = 1; // устанавливает 0-ой бит в PORT

45) операция инвертирования:
PORTB ^= 1; // меняет значение в 0-ой бите в PORT

46) STM32F411RE

47) 16-битные и 32-битные таймеры, SPI (I2S), I2C, USART, USB OTG FS, SDIO, 12-битный АЦП, датчик температуры.

48) Присутствие аппаратного модуля работы с плавающей точкой, присутствие набора инструкций DSP, SIMD, FP.

49) STM32F411 – линейка с оптимизированной динамической потребляемой мощностью и увеличенным объемом ОЗУ (до 128 кбайт). Максимальная рабочая частота этих микроконтроллеров достигает 100 МГц.

50) Настраиваемые источники тактовой частоты, настраиваемые на различные функции порты, внутренний температурный сенсор ,таймеры с настраиваемым модулем ШИМ
DMA для работы с модулями (SPI, UART, ADC… ) ,12 разрядный ADC последовательного приближения ,Часы реального времени
,системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ.

51) HSI (high-speed internal) — внутренний высокочастотный RC-генератор.

HSE (high-speed external) — внешний высокочастотный генератор.

PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей, исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.

LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц

LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц

52) Алгоритм настройки частоты Определить какие источники частоты нужны

Например, PLL нужен для USB

Включить нужный источник

Используя Clock Control register (RCC::CR)

Дождаться стабилизации источника

Используя соответствующие биты (..RDY) Clock Control register (RCC::CR)

Назначить нужный источник на системную частоту

Используя Clock Configuration Register (RCC::CFGR)

Дождаться пока источник не переключиться на системную частоту

Используя Clock Configuration Register (RCC::CFGR)

53) Фазовая автоподстройка частоты (ФАПЧ, англ. PLL ) — система автоматического регулирования, подстраивающая фазу управляемого генератора так, чтобы она была равна фазе опорного сигнала, либо отличалась на известную функцию от времени.

54) Код меняет значение StudentUdacha с значением PrepodUdachca.